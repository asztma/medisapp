import streamlit as st
import pandas as pd
import numpy as np
from io import BytesIO
from datetime import datetime
import os

# Настройки страницы
st.set_page_config(layout="wide", page_title="Финансовые отчёты")

CORRECT_PASSWORD = "34medisadmin"
def check_password():
    """Проверяет пароль и возвращает True если он верный"""
    if 'password_verified' not in st.session_state:
        st.session_state.password_verified = False
    
    if not st.session_state.password_verified:
        st.warning("Для доступа к управлению справочниками введите пароль")
        password = st.text_input("Пароль:", type="password", key="pwd_input")
        
        if st.button("Войти"):
            if password == CORRECT_PASSWORD:
                st.session_state.password_verified = True
                st.rerun()  # Перезагружаем страницу для обновления интерфейса
            else:
                st.error("Неверный пароль. Попробуйте снова.")
        return False
    return True

# Пути к CSV-файлам со справочниками
COST_ITEMS_MAPPING_CSV = "cost_items_mapping.csv"
COST_ITEMS_SUBSECTIONS_CSV = "cost_items_subsections.csv"
ADMIN_COST_ITEMS_MAPPING_CSV = "admin_cost_items_mapping.csv"
ADMIN_COST_ITEMS_SUBSECTIONS_CSV = "admin_cost_items_subsections.csv"

def load_or_create_mapping(file_path, default_data=None):
    """Загружает справочник из CSV или создает новый с default_data"""
    if os.path.exists(file_path):
        df = pd.read_csv(file_path)
        return dict(zip(df.iloc[:, 0], df.iloc[:, 1]))
    elif default_data is not None:
        df = pd.DataFrame(list(default_data.items()), columns=['Original', 'Mapped'])
        df.to_csv(file_path, index=False)
        return default_data
    return {}

# Загрузка или создание справочников
COST_ITEMS_MAPPING = load_or_create_mapping(
    COST_ITEMS_MAPPING_CSV,
    {
    "Хозяйственные услуги": "Хозяйственные услуги",
    "Амортизация": "Амортизация основных средств",
    "Расходы по аренде автотранспорта": "Расходы по аренде автотранспорта",
    "Аренда гаражей и стоянок": "Аренда гаражей и стоянок",
    "Расходы по аренде помещений": "Расходы по аренде помещений",
    "Расходы по аренде прочего имущества": "Расходы по аренде прочего имущества",
    "Бланки, карты, журналы медицинские": "Бланки, карты, журналы медицинские",
    "Вакцина": "Вакцина",
    "Водоснабжение и канализация": "Водоснабжение и канализация",
    "Вывоз мусора": "Вывоз мусора",
    "ГСМ для а/м": "ГСМ для а/м",
    "Дератизация и дезинсекция": "Дератизация и дезинсекция",
    "ДМС работников (3% от ФОТ)": "ДМС работников (3% от ФОТ)",
    "Услуги доставки, тарнспортировки грузов": "Услуги доставки, тарнспортировки грузов",
    "Интернет и передача данных": "Интернет и передача данных",
    "Канцелярские товары": "Канцелярские товары",
    "Командировочные": "Командировочные",
    "Компенсация проезда к местам отдыха (льготный проезд)": "Компенсация проезда к местам отдыха (льготный проезд)",
    "Медикаменты": "Медикаменты",
    "Медицинский инструментарий и прочий инвентарь многоразового использования": "Медицинский инструментарий и прочий инвентарь многоразового использования",
    "Метрология": "Метрология",
    "Моющие и дезинфицирующие средства": "Моющие и дезинфицирующие средства",
    "Мягкий инвентарь": "Мягкий инвентарь",
    "Расходы на обучение и повышение квалификации": "Расходы на обучение",
    "Оплата труда": "Оплата труда",
    "Организация питания (в санаторно-профилактических учреждениях)": "Организация питания (в санаторно-профилактических учреждениях)",
    "Питание, проживание на вахте": "Питание, проживание на вахте",
    "Охрана зданий": "Питание, проживание на вахте",
    "Междугородные перевозки сотрудников к месту работы": "Междугородные перевозки сотрудников к месту работы",
    "Подбор персонала": "Подбор персонала",
    "Пожарная безопасность": "Пожарная безопасность",
    "Приобретение мед. оборудования (до 100 тыс. руб.)": "Приобретение мед. оборудования (до 100 тыс. руб.)",
    "Приобретение оргтехники (до 100 тыс. руб.)": "Приобретение оргтехники (до 100 тыс. руб.)",
    "Приобретение прочего. оборудования (до 100 тыс. руб.)": "Приобретение прочего. оборудования (до 100 тыс. руб.)",
    "Прочие на содержание автотранспорта": "Прочие на содержание автотранспорта",
    "Расходные материалы": "Расходные материалы",
    "Расходные материалы ИТ": "Расходные материалы ИТ",
    "Реклама, продвижение": "Реклама, продвижение",
    "ТО и ремонт медицинского оборудования (материалы)": "ТО и ремонт медицинского оборудования (материалы)",
    "ТО и ремонт медицинского оборудования (услуги)": "ТО и ремонт медицинского оборудования (услуги)",
    "Ремонт и ТО автотранспорта": "Ремонт и ТО автотранспорта",
    "Ремонт офисной мебели, оборудования общего назначения": "Ремонт офисной мебели, оборудования общего назначения",
    "Ремонт помещений": "Ремонт помещений",
    "Техническое обслуживание системы вентиляции и кондиционирования": "Техническое обслуживание системы вентиляции и кондиционирования",
    "Сопровождение информационных систем": "Сопровождение информационных систем",
    "Специальная оценка условий труда": "Специальная оценка условий труда",
    "Спец одежда, спец обувь": "Спец одежда, спец обувь",
    "Стирка белья": "Прочие налоги, сборы, пошлины",
    "Сторонние ЛПУ": "Сторонние ЛПУ",
    "Страхование автотранспорта": "Страхование автотранспорта",
    "Страховые взносы": "Страховые взносы",
    "Страховые взносы": "Страховые взносы",
    "Страховые взносы": "Страховые взносы",
    "Телефон и телефонные переговоры (в т.ч. сотовая связь)": "Телефон и телефонные переговоры (в т.ч. сотовая связь)",
    "Тепловая энергия (отопление и горячая вода)": "Тепловая энергия (отопление и горячая вода)",
    "ТО прочих коммунальных систем": "ТО прочих коммунальных систем",
    "Уборка помещений, клининг": "Уборка помещений, клининг",
    "Уборка территории": "Уборка территории",
    "Услуги по обслуживанию и ремонту оборудования ИТ": "Услуги по обслуживанию и ремонту оборудования ИТ",
    "Услуги по обслуживанию и ремонту помещений ИТ": "Услуги по обслуживанию и ремонту помещений ИТ",
    "Услуги СЭС": "Услуги СЭС",
    "Утилизация медицинских отходов": "Утилизация медицинских отходов",
    "Хозяйственные товары": "Хозяйственные услуги",
    "Электроэнергия": "Электроэнергия",
    "Замещение": "Замещение",
    "Вахтовые": "Вахтовые"
    }
)

COST_ITEMS_SUBSECTIONS = load_or_create_mapping(
    COST_ITEMS_SUBSECTIONS_CSV,
    {
    "Хозяйственные услуги": "Прочие расходы",
    "Амортизация": "Амортизация основных средств",
    "Расходы по аренде автотранспорта": "Прочие расходы",
    "Аренда гаражей и стоянок": "Прочие расходы",
    "Расходы по аренде помещений": "Прочие расходы",
    "Расходы по аренде прочего имущества": "Прочие расходы",
    "Бланки, карты, журналы медицинские": "Материальные производственные расходы",
    "Вакцина": "Материальные производственные расходы",
    "Водоснабжение и канализация": "Прочие расходы",
    "Вывоз мусора": "Прочие расходы",
    "ГСМ для а/м": "Прочие расходы",
    "Дератизация и дезинсекция": "Прочие расходы",
    "ДМС работников (3% от ФОТ)": "ДМС работников (3% от ФОТ)",
    "Услуги доставки, тарнспортировки грузов": "Прочие расходы",
    "Интернет и передача данных": "Прочие расходы",
    "Канцелярские товары": "Материальные производственные расходы",
    "Командировочные": "Прочие расходы",
    "Компенсация проезда к местам отдыха (льготный проезд)": "Прочие расходы",
    "Медикаменты": "Материальные производственные расходы",
    "Медицинский инструментарий и прочий инвентарь многоразового использования": "Материальные производственные расходы",
    "Метрология": "Прочие расходы",
    "Моющие и дезинфицирующие средства": "Материальные производственные расходы",
    "Мягкий инвентарь": "Материальные производственные расходы",
    "Расходы на обучение": "Прочие расходы",
    "Оплата труда": "Заработная плата",
    "Организация питания (в санаторно-профилактических учреждениях)": "Прочие расходы",
    "Питание, проживание на вахте": "Прочие расходы",
    "Междугородные перевозки сотрудников к месту работы": "Прочие расходы",
    "Подбор персонала": "Прочие расходы",
    "Пожарная безопасность": "Прочие расходы",
    "Приобретение мед. оборудования (до 100 тыс. руб.)": "Материальные производственные расходы",
    "Приобретение оргтехники (до 100 тыс. руб.)": "Материальные производственные расходы",
    "Приобретение прочего. оборудования (до 100 тыс. руб.)": "Материальные производственные расходы",
    "Прочие на содержание автотранспорта": "Прочие расходы",
    "Расходные материалы": "Материальные производственные расходы",
    "Расходные материалы ИТ": "Материальные производственные расходы",
    "Реклама, продвижение": "Прочие расходы",
    "ТО и ремонт медицинского оборудования (материалы)": "Материальные производственные расходы",
    "ТО и ремонт медицинского оборудования (услуги)": "Материальные производственные расходы",
    "Ремонт и ТО автотранспорта": "Прочие расходы",
    "Ремонт офисной мебели, оборудования общего назначения": "Прочие расходы",
    "Ремонт помещений": "Прочие расходы",
    "Техническое обслуживание системы вентиляции и кондиционирования": "Прочие расходы",
    "Сопровождение информационных систем": "Прочие расходы",
    "Специальная оценка условий труда": "Прочие расходы",
    "Спец одежда, спец обувь": "Материальные производственные расходы",
    "Прочие налоги, сборы, пошлины": "Прочие расходы",
    "Сторонние ЛПУ": "Прочие расходы",
    "Страхование автотранспорта": "Прочие расходы",
    "Страховые взносы": "Заработная плата",
    "Телефон и телефонные переговоры (в т.ч. сотовая связь)": "Прочие расходы",
    "Тепловая энергия (отопление и горячая вода)": "Прочие расходы",
    "ТО прочих коммунальных систем": "Прочие расходы",
    "Уборка помещений, клининг": "Прочие расходы",
    "Уборка территории": "Прочие расходы",
    "Услуги по обслуживанию и ремонту оборудования ИТ": "Прочие расходы",
    "Услуги по обслуживанию и ремонту помещений ИТ": "Прочие расходы",
    "Услуги СЭС": "Прочие расходы",
    "Утилизация медицинских отходов": "Прочие расходы",
    "Электроэнергия": "Прочие расходы",
    "Замещение": "Заработная плата",
    "Вахтовые": "Заработная плата"
    }
)

ADMIN_COST_ITEMS_MAPPING = load_or_create_mapping(
    ADMIN_COST_ITEMS_MAPPING_CSV,
    {
    'Хозяйственные услуги': 'Хозяйственные услуги',
    'Амортизация': 'Амортизация основных средств',
    'Расходы по аренде автотранспорта': 'Расходы по аренде автотранспорта',
    'Аренда гаражей и стоянок': 'Аренда гаражей и стоянок',
    'Расходы по аренде помещений': 'Расходы по аренде помещений',
    'Расходы по аренде прочего имущества': 'Расходы по аренде прочего имущества',
    'Аудит': 'Аудит',
    'Безопасность ИТ': 'Безопасность ИТ',
    'Водоснабжение и канализация': 'Водоснабжение и канализация',
    'Вознаграждения по договорам ГПХ': 'Оплата труда',
    'Вывоз мусора': 'Вывоз мусора',
    'ГСМ для а/м': 'ГСМ для а/м',
    'ДМС работников (3% от ФОТ)': 'ДМС работников (3% от ФОТ)',
    'Услуги доставки, тарнспортировки грузов': 'Услуги доставки, тарнспортировки грузов',
    'Интернет и передача данных': 'Интернет и передача данных',
    'ИТ аутсорсинг': 'ИТ аутсорсинг',
    'Канцелярские товары': 'Канцелярские товары',
    'Командировочные': 'Командировочные',
    'Корпоративные мероприятия': 'Корпоративные мероприятия',
    'Консультационные услуги (в т.ч. В связи с лицензированием)': 'Консультационные услуги (в т.ч. В связи с лицензированием)',
    'Налог на имущество': 'Налог на имущество',
    'Прочие налоги, сборы, пошлины': 'Прочие налоги, сборы, пошлины',
    'Расходы на обучение и повышение квалификации': 'Расходы на обучение',
    'Оплата труда': 'Оплата труда',
    'Охрана зданий': 'Питание, проживание на вахте',
    'Подбор персонала': 'Подбор персонала',
    'Подписка и приобретение периодических изданий и книг': 'Подписка и приобретение периодических изданий и книг',
    'Пожарная безопасность': 'Пожарная безопасность',
    'Почтовые услуги, телеграф': 'Почтовые услуги, телеграф',
    'Представительские': 'Представительские',
    'Приобретение ПО и лицензий': 'Приобретение ПО и лицензий',
    'Приобретение прочего. оборудования (до 100 тыс. руб.)': 'Приобретение прочего. оборудования (до 100 тыс. руб.)',
    'Прочие на содержание автотранспорта': 'Прочие на содержание автотранспорта',
    'Расходные материалы ИТ': 'Расходные материалы ИТ',
    'Реклама, продвижение': 'Реклама, продвижение',
    'Ремонт и ТО автотранспорта': 'Ремонт и ТО автотранспорта',
    'Ремонт офисной мебели, оборудования общего назначения': 'Ремонт офисной мебели, оборудования общего назначения',
    'Ремонт помещений': 'Ремонт помещений',
    'Техническое обслуживание системы вентиляции и кондиционирования': 'Техническое обслуживание системы вентиляции и кондиционирования',
    'Сопровождение информационных систем': 'Сопровождение информационных систем',
    'Специальная оценка условий труда': 'Специальная оценка условий труда',
    'Страхование автотранспорта': 'Страхование автотранспорта',
    'Страховые взносы': 'Страховые взносы',
    'Телефон и телефонные переговоры (в т.ч. сотовая связь)': 'Телефон и телефонные переговоры (в т.ч. сотовая связь)',
    'Тепловая энергия (отопление и горячая вода)': 'Тепловая энергия (отопление и горячая вода)',
    'ТО прочих коммунальных систем': 'ТО прочих коммунальных систем',
    'Уборка помещений, клининг': 'Уборка помещений, клининг',
    'Уборка территории': 'Уборка территории',
    'Услуги по обслуживанию и ремонту оборудования ИТ': 'Услуги по обслуживанию и ремонту оборудования ИТ',
    'Услуги по обслуживанию и ремонту помещений ИТ': 'Услуги по обслуживанию и ремонту помещений ИТ',
    'Хозяйственные товары': 'Хозяйственные услуги',
    'Электроэнергия': 'Электроэнергия',
    'Юридические услуги (в т.ч. нотариальные)': 'Юридические услуги (в т.ч. нотариальные)',
    'Замещение': 'Замещение',
    'Вахтовые': 'Вахтовые'
    }
)

ADMIN_COST_ITEMS_SUBSECTIONS = load_or_create_mapping(
    ADMIN_COST_ITEMS_SUBSECTIONS_CSV,
    {
    'Хозяйственные услуги': 'Прочие расходы',
    'Амортизация': 'Амортизация основных средств',
    'Расходы по аренде автотранспорта': 'Прочие расходы',
    'Аренда гаражей и стоянок': 'Прочие расходы',
    'Расходы по аренде помещений': 'Прочие расходы',
    'Расходы по аренде прочего имущества': 'Прочие расходы',
    'Аудит': 'Прочие расходы',
    'Безопасность ИТ': 'Прочие расходы',
    'Водоснабжение и канализация': 'Прочие расходы',
    'Оплата труда': 'Заработная плата',
    'Вывоз мусора': 'Прочие расходы',
    'ГСМ для а/м': 'Прочие расходы',
    'ДМС работников (3% от ФОТ)': 'ДМС работников (3% от ФОТ)',
    'Услуги доставки, тарнспортировки грузов': 'Прочие расходы',
    'Интернет и передача данных': 'Прочие расходы',
    'ИТ аутсорсинг': 'Прочие расходы',
    'Канцелярские товары': 'Материальные производственные расходы',
    'Командировочные': 'Прочие расходы',
    'Корпоративные мероприятия': 'Прочие расходы',
    'Консультационные услуги (в т.ч. В связи с лицензированием)': 'Прочие расходы',
    'Налог на имущество': 'Прочие расходы',
    'Прочие налоги, сборы, пошлины': 'Прочие расходы',
    'Расходы на обучение': 'Прочие расходы',
    'Питание, проживание на вахте': 'Прочие расходы',
    'Подбор персонала': 'Прочие расходы',
    'Подписка и приобретение периодических изданий и книг': 'Прочие расходы',
    'Пожарная безопасность': 'Прочие расходы',
    'Почтовые услуги, телеграф': 'Прочие расходы',
    'Представительские': 'Прочие расходы',
    'Приобретение ПО и лицензий': 'Материальные производственные расходы',
    'Приобретение прочего. оборудования (до 100 тыс. руб.)': 'Материальные производственные расходы',
    'Прочие на содержание автотранспорта': 'Прочие расходы',
    'Расходные материалы ИТ': 'Материальные производственные расходы',
    'Реклама, продвижение': 'Прочие расходы',
    'Ремонт и ТО автотранспорта': 'Прочие расходы',
    'Ремонт офисной мебели, оборудования общего назначения': 'Прочие расходы',
    'Ремонт помещений': 'Прочие расходы',
    'Техническое обслуживание системы вентиляции и кондиционирования': 'Прочие расходы',
    'Сопровождение информационных систем': 'Прочие расходы',
    'Специальная оценка условий труда': 'Прочие расходы',
    'Страхование автотранспорта': 'Прочие расходы',
    'Страховые взносы': 'Заработная плата',
    'Телефон и телефонные переговоры (в т.ч. сотовая связь)': 'Прочие расходы',
    'Тепловая энергия (отопление и горячая вода)': 'Прочие расходы',
    'ТО прочих коммунальных систем': 'Прочие расходы',
    'Уборка помещений, клининг': 'Прочие расходы',
    'Уборка территории': 'Прочие расходы',
    'Услуги по обслуживанию и ремонту оборудования ИТ': 'Прочие расходы',
    'Услуги по обслуживанию и ремонту помещений ИТ': 'Прочие расходы',
    'Электроэнергия': 'Прочие расходы',
    'Юридические услуги (в т.ч. нотариальные)': 'Прочие расходы',
    'Замещение': 'Заработная плата',
    'Вахтовые': 'Заработная плата'
    }
)

def normalize_cost_items(df):
    """Нормализует названия статей затрат и добавляет подразделы"""
    df["Статья затрат УУ"] = df["Статья затрат УУ"].map(COST_ITEMS_MAPPING).fillna(df["Статья затрат УУ"])
    df["Подраздел"] = df["Статья затрат УУ"].map(COST_ITEMS_SUBSECTIONS).fillna("Прочие расходы")
    return df

def normalize_admin_cost_items(df):
    """Нормализует статьи затрат и подразделы для управленческого отчета"""
    df["Статья затрат УУ"] = df["Статья затрат УУ"].map(ADMIN_COST_ITEMS_MAPPING).fillna(df["Статья затрат УУ"])
    df["Подраздел"] = df["Статья затрат УУ"].map(ADMIN_COST_ITEMS_SUBSECTIONS).fillna("Прочие расходы")
    return df

def create_report(expense_plan_df, expense_fact_df):
    """
    Создаёт отчёт с корректным расчётом сумм по подразделам
    """
    # Проверка обязательных столбцов
    required_columns = {'Сумма', 'Статья затрат УУ', 'НД'}
    for col in required_columns:
        if col not in expense_plan_df.columns or col not in expense_fact_df.columns:
            raise ValueError(f"Отсутствует обязательный столбец: {col}")

    # Определяем тип отчёта по наличию номенклатурной группы
    is_budget_report = 'Номенклатурная группа' in expense_plan_df.columns and 'Номенклатурная группа' in expense_fact_df.columns
    is_budget_report = is_budget_report and not expense_plan_df['Номенклатурная группа'].isna().all()
    is_budget_report = is_budget_report and not expense_fact_df['Номенклатурная группа'].isna().all()

    # Фильтрация данных для "Сметы"
    if is_budget_report:
        expense_plan_df = expense_plan_df[expense_plan_df['Номенклатурная группа'].notna()]
        expense_fact_df = expense_fact_df[expense_fact_df['Номенклатурная группа'].notna()]

    # Нормализация данных
    expense_plan_df = normalize_cost_items(expense_plan_df)
    expense_fact_df = normalize_cost_items(expense_fact_df)

    # Группировка данных по статьям затрат
    group_cols = ['Подраздел', 'Статья затрат УУ']
    
    # Обработка НД: суммы считаются только если НД == 1
    expense_plan_df['НД'] = expense_plan_df['НД'].fillna(0)
    expense_fact_df['НД'] = expense_fact_df['НД'].fillna(0)
    expense_plan_df['НД сумма'] = np.where(expense_plan_df['НД'] == 1, expense_plan_df['Сумма'], 0)
    expense_fact_df['НД сумма'] = np.where(expense_fact_df['НД'] == 1, expense_fact_df['Сумма'], 0)

    # Группировка плановых расходов
    plan_grouped = expense_plan_df.groupby(group_cols).agg({
        'Сумма': 'sum',
        'НД': 'sum'
    }).reset_index()
    plan_grouped.rename(columns={'Сумма': 'План', 'НД': 'План НД'}, inplace=True)

    # Группировка фактических расходов
    fact_grouped = expense_fact_df.groupby(group_cols).agg({
        'Сумма': 'sum',
        'НД': 'sum'
    }).reset_index()
    fact_grouped.rename(columns={'Сумма': 'Факт', 'НД': 'Факт НД'}, inplace=True)

    # Объединение данных
    merged_df = pd.merge(
        plan_grouped,
        fact_grouped,
        on=group_cols,
        how='outer'
    ).fillna(0)

    # Расчёт отклонений
    merged_df['Отклонение'] = merged_df['Факт'] - merged_df['План']
    merged_df['Отклонение НД'] = merged_df['Факт НД'] - merged_df['План НД']

    # Создаём структуру отчёта с корректными суммами по подразделам
    report_data = []
    subsection_counter = 1
    
    # Сначала считаем суммы по подразделам
    subsection_totals = merged_df.groupby('Подраздел').agg({
        'План': 'sum',
        'Факт': 'sum',
        'Отклонение': 'sum',
        'План НД': 'sum',
        'Факт НД': 'sum',
        'Отклонение НД': 'sum'
    }).reset_index()
    
    # Общие итоги
    total_plan = merged_df['План'].sum()
    total_fact = merged_df['Факт'].sum()
    total_deviation = total_fact - total_plan
    total_plan_nd = merged_df['План НД'].sum()
    total_fact_nd = merged_df['Факт НД'].sum()
    total_deviation_nd = total_fact_nd - total_plan_nd
    
    # Сортируем данные
    merged_df.sort_values(by=['Подраздел', 'Статья затрат УУ'], inplace=True)
    
    # Формируем отчёт
    for subsection in subsection_totals['Подраздел'].unique():
        # Добавляем строку подраздела
        subsection_row = subsection_totals[subsection_totals['Подраздел'] == subsection].iloc[0]
        report_data.append({
            'Код строки': f"{subsection_counter}.",
            'Статья расходов': subsection,
            'План': subsection_row['План'],
            'Факт': subsection_row['Факт'],
            'Отклонение': subsection_row['Отклонение'],
            'План НД': subsection_row['План НД'],
            'Факт НД': subsection_row['Факт НД'],
            'Отклонение НД': subsection_row['Отклонение НД'],
            'is_subsection': True
        })
        
        # Добавляем статьи затрат этого подраздела
        items = merged_df[merged_df['Подраздел'] == subsection]
        item_counter = 1
        for _, item in items.iterrows():
            report_data.append({
                'Код строки': f"{subsection_counter}.{item_counter}",
                'Статья расходов': item['Статья затрат УУ'],
                'План': item['План'],
                'Факт': item['Факт'],
                'Отклонение': item['Отклонение'],
                'План НД': item['План НД'],
                'Факт НД': item['Факт НД'],
                'Отклонение НД': item['Отклонение НД'],
                'is_subsection': False
            })
            item_counter += 1
        
        subsection_counter += 1
    
    # Добавляем итоговую строку
    report_data.append({
        'Код строки': 'Итого',
        'Статья расходов': '',
        'План': total_plan,
        'Факт': total_fact,
        'Отклонение': total_deviation,
        'План НД': total_plan_nd,
        'Факт НД': total_fact_nd,
        'Отклонение НД': total_deviation_nd,
        'is_subsection': False
    })
    
    report_df = pd.DataFrame(report_data)
    return report_df, is_budget_report

def create_admin_report(expense_plan_df, expense_fact_df):
    """
    Создаёт отчёт с корректным расчётом сумм по подразделам
    """
    # Проверка обязательных столбцов
    required_columns = {'Сумма', 'Статья затрат УУ', 'НД'}
    for col in required_columns:
        if col not in expense_plan_df.columns or col not in expense_fact_df.columns:
            raise ValueError(f"Отсутствует обязательный столбец: {col}")

    # Определяем тип отчёта по наличию номенклатурной группы
    is_budget_report = 'Номенклатурная группа' in expense_plan_df.columns and 'Номенклатурная группа' in expense_fact_df.columns
    is_budget_report = is_budget_report and not expense_plan_df['Номенклатурная группа'].isna().all()
    is_budget_report = is_budget_report and not expense_fact_df['Номенклатурная группа'].isna().all()

    # Фильтрация данных для "Сметы"
    if is_budget_report:
        expense_plan_df = expense_plan_df[expense_plan_df['Номенклатурная группа'].isna()]
        expense_fact_df = expense_fact_df[expense_fact_df['Номенклатурная группа'].isna()]

    # Нормализация данных
    expense_plan_df = normalize_admin_cost_items(expense_plan_df)
    expense_fact_df = normalize_admin_cost_items(expense_fact_df)

    # Группировка данных по статьям затрат
    group_cols = ['Подраздел', 'Статья затрат УУ']
    
    # Обработка НД: суммы считаются только если НД == 1
    expense_plan_df['НД'] = expense_plan_df['НД'].fillna(0)
    expense_fact_df['НД'] = expense_fact_df['НД'].fillna(0)
    expense_plan_df['НД сумма'] = np.where(expense_plan_df['НД'] == 1, expense_plan_df['Сумма'], 0)
    expense_fact_df['НД сумма'] = np.where(expense_fact_df['НД'] == 1, expense_fact_df['Сумма'], 0)

    # Группировка плановых расходов
    plan_grouped = expense_plan_df.groupby(group_cols).agg({
        'Сумма': 'sum',
        'НД': 'sum'
    }).reset_index()
    plan_grouped.rename(columns={'Сумма': 'План', 'НД': 'План НД'}, inplace=True)

    # Группировка фактических расходов
    fact_grouped = expense_fact_df.groupby(group_cols).agg({
        'Сумма': 'sum',
        'НД': 'sum'
    }).reset_index()
    fact_grouped.rename(columns={'Сумма': 'Факт', 'НД': 'Факт НД'}, inplace=True)

    # Объединение данных
    merged_df = pd.merge(
        plan_grouped,
        fact_grouped,
        on=group_cols,
        how='outer'
    ).fillna(0)

    # Расчёт отклонений
    merged_df['Отклонение'] = merged_df['Факт'] - merged_df['План']
    merged_df['Отклонение НД'] = merged_df['Факт НД'] - merged_df['План НД']

    # Создаём структуру отчёта с корректными суммами по подразделам
    report_data = []
    subsection_counter = 1
    
    # Сначала считаем суммы по подразделам
    subsection_totals = merged_df.groupby('Подраздел').agg({
        'План': 'sum',
        'Факт': 'sum',
        'Отклонение': 'sum',
        'План НД': 'sum',
        'Факт НД': 'sum',
        'Отклонение НД': 'sum'
    }).reset_index()
    
    # Общие итоги
    total_plan = merged_df['План'].sum()
    total_fact = merged_df['Факт'].sum()
    total_deviation = total_fact - total_plan
    total_plan_nd = merged_df['План НД'].sum()
    total_fact_nd = merged_df['Факт НД'].sum()
    total_deviation_nd = total_fact_nd - total_plan_nd
    
    # Сортируем данные
    merged_df.sort_values(by=['Подраздел', 'Статья затрат УУ'], inplace=True)
    
    # Формируем отчёт
    for subsection in subsection_totals['Подраздел'].unique():
        # Добавляем строку подраздела
        subsection_row = subsection_totals[subsection_totals['Подраздел'] == subsection].iloc[0]
        report_data.append({
            'Код строки': f"{subsection_counter}.",
            'Статья расходов': subsection,
            'План': subsection_row['План'],
            'Факт': subsection_row['Факт'],
            'Отклонение': subsection_row['Отклонение'],
            'План НД': subsection_row['План НД'],
            'Факт НД': subsection_row['Факт НД'],
            'Отклонение НД': subsection_row['Отклонение НД'],
            'is_subsection': True
        })
        
        # Добавляем статьи затрат этого подраздела
        items = merged_df[merged_df['Подраздел'] == subsection]
        item_counter = 1
        for _, item in items.iterrows():
            report_data.append({
                'Код строки': f"{subsection_counter}.{item_counter}",
                'Статья расходов': item['Статья затрат УУ'],
                'План': item['План'],
                'Факт': item['Факт'],
                'Отклонение': item['Отклонение'],
                'План НД': item['План НД'],
                'Факт НД': item['Факт НД'],
                'Отклонение НД': item['Отклонение НД'],
                'is_subsection': False
            })
            item_counter += 1
        
        subsection_counter += 1
    
    # Добавляем итоговую строку
    report_data.append({
        'Код строки': 'Итого',
        'Статья расходов': '',
        'План': total_plan,
        'Факт': total_fact,
        'Отклонение': total_deviation,
        'План НД': total_plan_nd,
        'Факт НД': total_fact_nd,
        'Отклонение НД': total_deviation_nd,
        'is_subsection': False
    })
    
    report_df = pd.DataFrame(report_data)
    return report_df, is_budget_report

def main():
    st.title("Финансовые отчёты")
    
    # Создаём вкладки
    tab1, tab2, tab3, tab4, tab5 = st.tabs(["Смета", "Управленческие расходы", "Прибыль и убытки","Сводный отчет", "Справочники"])
    
    with tab1:
        st.header("Отчёт: Смета")
        
        # Загрузка файлов
        st.subheader("Загрузка данных")
        col1, col2 = st.columns(2)
        
        with col1:
            plan_file = st.file_uploader("Загрузите файл 'Расход план' (xlsx)", type="xlsx", key="plan_file")
        
        with col2:
            fact_file = st.file_uploader("Загрузите файл 'Расход факт' (xlsx)", type="xlsx", key="fact_file")
        
        # Загрузка дат
        date_range = st.date_input(
            "Выберите период отчёта",
            value=(datetime.now().replace(day=1), datetime.now()),
            format="DD.MM.YYYY",
            key="date_range"
        )
        
        if st.button("Сформировать отчёт", key="generate_report") and plan_file and fact_file:
            try:
                # Чтение файлов
                expense_plan_df = pd.read_excel(plan_file)
                expense_fact_df = pd.read_excel(fact_file)
                
                # Создание отчёта
                report_df, is_budget_report = create_report(expense_plan_df, expense_fact_df)
                
                # Вывод информации о типе отчёта
                if is_budget_report:
                    st.success("Сформирован отчёт 'Смета' (использованы только строки с заполненной номенклатурной группой)")
                else:
                    st.success("Сформирован отчёт 'Управленческие расходы'")
                
                # Вывод результатов
                st.subheader("Результаты")
                
                # Функция для стилизации строк
                def style_row(row):
                    if row['Код строки'] == 'Итого':
                        return ['font-weight: bold; background-color: #f0f0f0'] * len(row)
                    elif '.' in row['Код строки'] and not row['Код строки'].endswith('.'):
                        return [''] * len(row)
                    elif row['Код строки'].endswith('.'):
                        return ['font-weight: bold'] * len(row)
                    return [''] * len(row)
                
                # Показать таблицу
                st.dataframe(
                    report_df.style.format({
                        'План': '{:,.2f}',
                        'Факт': '{:,.2f}',
                        'Отклонение': '{:,.2f}',
                        'План НД': '{:,.2f}',
                        'Факт НД': '{:,.2f}',
                        'Отклонение НД': '{:,.2f}'
                    }).apply(style_row, axis=1),
                    use_container_width=True,
                    height=800,
                    hide_index=True,
                    column_config={
                        "Код строки": st.column_config.TextColumn(width="small"),
                        "Статья расходов": st.column_config.TextColumn(width="large"),
                        "План": st.column_config.NumberColumn(width="medium"),
                        "Факт": st.column_config.NumberColumn(width="medium"),
                        "Отклонение": st.column_config.NumberColumn(width="medium"),
                        "План НД": st.column_config.NumberColumn(width="medium"),
                        "Факт НД": st.column_config.NumberColumn(width="medium"),
                        "Отклонение НД": st.column_config.NumberColumn(width="medium")
                    }
                )
                
                # Экспорт в Excel
                report_period = f"{date_range[0].strftime('%d.%m.%Y')} – {date_range[1].strftime('%d.%m.%Y')}"
                excel_data = save_to_excel(report_df, report_period)
                
                report_name = "Смета" if is_budget_report else "Управленческие_расходы"
                st.download_button(
                    label="Скачать отчёт (Excel)",
                    data=excel_data,
                    file_name=f"{report_name}_{date_range[0].strftime('%d.%m.%Y')}_{date_range[1].strftime('%d.%m.%Y')}.xlsx",
                    mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                    key="download_report"
                )
                
            except Exception as e:
                st.error(f"Ошибка при обработке данных: {str(e)}")

    with tab2:
        st.header("Отчёт: Управленческие расходы")
        
        st.subheader("Загрузка данных")
        col1, col2 = st.columns(2)
        
        with col1:
            plan_file_admin = st.file_uploader("Загрузите файл 'Расход план' (xlsx)", type="xlsx", key="admin_plan_file")
        
        with col2:
            fact_file_admin = st.file_uploader("Загрузите файл 'Расход факт' (xlsx)", type="xlsx", key="admin_fact_file")
        
        date_range_admin = st.date_input(
            "Выберите период отчёта",
            value=(datetime.now().replace(day=1), datetime.now()),
            format="DD.MM.YYYY",
            key="date_range_admin"
        )
        
        if st.button("Сформировать управленческий отчёт", key="generate_admin_report") and plan_file_admin and fact_file_admin:
            try:
                expense_plan_df = pd.read_excel(plan_file_admin)
                expense_fact_df = pd.read_excel(fact_file_admin)
                
                report_df, _ = create_admin_report(expense_plan_df, expense_fact_df)
                
                st.success("Сформирован отчёт 'Управленческие расходы' (использованы только строки с пустой номенклатурной группой)")
                
                st.subheader("Результаты")

                def style_row(row):
                    if row['Код строки'] == 'Итого':
                        return ['font-weight: bold; background-color: #f0f0f0'] * len(row)
                    elif '.' in row['Код строки'] and not row['Код строки'].endswith('.'):
                        return [''] * len(row)
                    elif row['Код строки'].endswith('.'):
                        return ['font-weight: bold'] * len(row)
                    return [''] * len(row)

                st.dataframe(
                    report_df.style.format({
                        'План': '{:,.2f}',
                        'Факт': '{:,.2f}',
                        'Отклонение': '{:,.2f}',
                        'План НД': '{:,.2f}',
                        'Факт НД': '{:,.2f}',
                        'Отклонение НД': '{:,.2f}'
                    }).apply(style_row, axis=1),
                    use_container_width=True,
                    height=800,
                    hide_index=True,
                    column_config={
                        "Код строки": st.column_config.TextColumn(width="small"),
                        "Статья расходов": st.column_config.TextColumn(width="large"),
                        "План": st.column_config.NumberColumn(width="medium"),
                        "Факт": st.column_config.NumberColumn(width="medium"),
                        "Отклонение": st.column_config.NumberColumn(width="medium"),
                        "План НД": st.column_config.NumberColumn(width="medium"),
                        "Факт НД": st.column_config.NumberColumn(width="medium"),
                        "Отклонение НД": st.column_config.NumberColumn(width="medium")
                    }
                )

                report_period = f"{date_range_admin[0].strftime('%d.%m.%Y')} – {date_range_admin[1].strftime('%d.%m.%Y')}"
                excel_data = save_to_excel(report_df, report_period)
                st.download_button(
                    label="Скачать отчёт (Excel)",
                    data=excel_data,
                    file_name=f"Управленческие_расходы_{date_range_admin[0].strftime('%d.%m.%Y')}_{date_range_admin[1].strftime('%d.%m.%Y')}.xlsx",
                    mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                    key="download_admin_report"
                )

            except Exception as e:
                st.error(f"Ошибка при обработке данных: {str(e)}")
    with tab3:
        st.header("Отчёт: Прибыль и убытки")
        
        st.subheader("Загрузите 4 файла Excel")
        uploaded_files = st.file_uploader(
            "Выберите 4 файла (XLSX) с обязательными колонками: 'Сумма', 'Номенклатурная группа'",
            type="xlsx",
            accept_multiple_files=True,
            key="pnl_files"
        )

        if uploaded_files and len(uploaded_files) == 4:
            try:
                dfs = []
                for file in uploaded_files:
                    df = pd.read_excel(file)
                    # Проверяем наличие обязательных колонок
                    required_cols = ['Сумма', 'Номенклавурная группа']
                    missing_cols = [col for col in required_cols if col not in df.columns]
                    if missing_cols:
                        raise ValueError(f"Файл {file.name} не содержит колонок: {', '.join(missing_cols)}")
                    dfs.append(df)

                # Объединение данных из всех файлов
                combined_df = pd.concat(dfs, ignore_index=True)

                # Группировка по номенклатурной группе
                grouped_df = combined_df.groupby('Номенклавурная группа').agg({
                    'Сумма': 'sum'
                }).reset_index()

                grouped_df.rename(columns={'Сумма': 'Итого сумма'}, inplace=True)

                st.success("Данные успешно загружены и обработаны.")
                st.subheader("Сгруппированные данные по 'Номенклатурной группе'")
                st.dataframe(grouped_df, use_container_width=True, hide_index=False)

                # Экспорт в Excel
                output = BytesIO()
                with pd.ExcelWriter(output, engine='openpyxl') as writer:
                    grouped_df.to_excel(writer, index=False, sheet_name='Отчёт')
                excel_data = output.getvalue()

                st.download_button(
                    label="Скачать отчёт (Excel)",
                    data=excel_data,
                    file_name="Прибыль_и_убытки.xlsx",
                    mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                    key="download_pnl"
                )

            except Exception as e:
                st.error(f"Ошибка при обработке файлов: {str(e)}")

        elif uploaded_files and len(uploaded_files) != 4:
            st.warning("Пожалуйста, загрузите ровно 4 файла.")
        else:
            st.info("Ожидание загрузки 4 файлов...")

    with tab5:
        if check_password():
            st.header("Редактирование справочников")
            
            # Выбор справочника для редактирования
            dict_choice = st.selectbox(
                "Выберите справочник для редактирования",
                options=[
                    "Сопоставление статей затрат УУ и статей затрат в отчете(СМЕТА)",
                    "Сопоставление статей затрат и подразделов(СМЕТА)",
                    "Сопоставление статей затрат УУ и статей затрат в отчете(Управленческий)",
                    "Сопоставление статей затрат и подразделов(Управленческий)"
                ],
                index=0
            )
            
            # Загрузка соответствующего справочника
            if dict_choice == "Сопоставление статей затрат УУ и статей затрат в отчете(СМЕТА)":
                file_path = COST_ITEMS_MAPPING_CSV
                dict_name = "Сопоставление статей затрат УУ и статей затрат в отчете(СМЕТА)"

            elif dict_choice == "Сопоставление статей затрат и подразделов(СМЕТА)":
                file_path = COST_ITEMS_SUBSECTIONS_CSV
                dict_name = "Сопоставление статей затрат и подразделов(СМЕТА)"

            elif dict_choice == "Сопоставление статей затрат УУ и статей затрат в отчете(Управленческий)":
                file_path = ADMIN_COST_ITEMS_MAPPING_CSV
                dict_name = "Сопоставление статей затрат УУ и статей затрат в отчете(Управленческий)"

            elif dict_choice == "Сопоставление статей затрат и подразделов(Управленческий)":
                file_path = ADMIN_COST_ITEMS_SUBSECTIONS_CSV
                dict_name = "Сопоставление статей затрат и подразделов(Управленческий)"
            
            st.subheader(dict_name)
            
            # Загрузка данных из CSV
            if os.path.exists(file_path):
                df = pd.read_csv(file_path)
            else:
                df = pd.DataFrame(columns=['Original', 'Mapped'])
            
            # Редактируемая таблица
            edited_df = st.data_editor(
                df,
                num_rows="dynamic",
                use_container_width=True,
                column_config={
                    "Original": st.column_config.TextColumn("Оригинальное название"),
                    "Mapped": st.column_config.TextColumn("Сопоставленное название")
                }
            )
            
            # Кнопки для сохранения/сброса
            col1, col2 = st.columns(2)
            
            with col1:
                if st.button("Сохранить изменения", key=f"save_{dict_choice}"):
                    edited_df.to_csv(file_path, index=False)
                    st.success("Изменения сохранены!")
                    # Обновляем справочники в памяти
                    if dict_choice == "Сопоставление статей затрат УУ и статей затрат в отчете(СМЕТА)":
                        COST_ITEMS_MAPPING = dict(zip(edited_df['Original'], edited_df['Mapped']))
                    elif dict_choice == "Сопоставление статей затрат и подразделов(СМЕТА)":
                        COST_ITEMS_SUBSECTIONS = dict(zip(edited_df['Original'], edited_df['Mapped']))
                    elif dict_choice == "Сопоставление статей затрат УУ и статей затрат в отчете(Управленческий)":
                        ADMIN_COST_ITEMS_MAPPING = dict(zip(edited_df['Original'], edited_df['Mapped']))
                    elif dict_choice == "Сопоставление статей затрат и подразделов(Управленческий)":
                        ADMIN_COST_ITEMS_SUBSECTIONS = dict(zip(edited_df['Original'], edited_df['Mapped']))
            
            with col2:
                # Экспорт в Excel
                excel_data = BytesIO()
                with pd.ExcelWriter(excel_data, engine='openpyxl') as writer:
                    edited_df.to_excel(writer, index=False, sheet_name=dict_choice)
                st.download_button(
                    label="Экспорт в Excel",
                    data=excel_data.getvalue(),
                    file_name=f"{dict_choice}.xlsx",
                    mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                )

    with tab4:
        st.header("Сводный отчет по нескольким файлам")
        
        # Загрузка файлов
        uploaded_files = st.file_uploader(
            "Загрузите от 1 до 30 файлов для сводного отчета",
            type=["xlsx"],
            accept_multiple_files=True,
            key="consolidated_files"
        )
        
        if uploaded_files and len(uploaded_files) > 0:
            if len(uploaded_files) > 30:
                st.error("Максимальное количество файлов - 30")
            else:
                try:
                    # Чтение всех файлов с пропуском строки "Период отчета:"
                    dfs = []
                    for file in uploaded_files:
                        # Читаем файл, пропуская строки, содержащие "Период отчета:"
                        df = pd.read_excel(file)
                        df = df[~df.iloc[:, 0].astype(str).str.contains('Период отчета:', na=False)]
                        
                        # Проверка обязательных колонок
                        required_columns = ['Код строки', 'Статья расходов', 'План', 'Факт', 'Отклонение', 
                                        'План НД', 'Факт НД', 'Отклонение НД']
                        if not all(col in df.columns for col in required_columns):
                            st.error(f"Файл {file.name} не содержит всех необходимых колонок")
                            continue
                        
                        # Преобразуем код строки в строковый тип
                        df['Код строки'] = df['Код строки'].astype(str)
                        dfs.append(df)
                    
                    if len(dfs) == 0:
                        st.error("Нет файлов с корректной структурой")
                    else:
                        # Объединение данных
                        all_data = pd.concat(dfs)
                        
                        # Группировка по статье расходов и суммирование
                        numeric_cols = ['План', 'Факт', 'Отклонение', 'План НД', 'Факт НД', 'Отклонение НД']
                        grouped_data = all_data.groupby(['Код строки', 'Статья расходов'])[numeric_cols].sum().reset_index()
                        
                        # Создаем итоговую строку
                        total_row = {
                            'Код строки': 'ИТОГО',
                            'Статья расходов': '',
                            'План': grouped_data['План'].sum(),
                            'Факт': grouped_data['Факт'].sum(),
                            'Отклонение': grouped_data['Факт'].sum() - grouped_data['План'].sum(),
                            'План НД': grouped_data['План НД'].sum(),
                            'Факт НД': grouped_data['Факт НД'].sum(),
                            'Отклонение НД': grouped_data['Факт НД'].sum() - grouped_data['План НД'].sum()
                        }
                        
                        # Добавляем итоговую строку в DataFrame
                        consolidated_df = pd.concat([grouped_data, pd.DataFrame([total_row])], ignore_index=True)
                        
                        # Функция для сортировки кодов строк
                        def sort_key(code):
                            if not isinstance(code, str):
                                code = str(code)
                            if code == 'ИТОГО':
                                return (float('inf'),)  # Итого всегда в конце
                            if pd.isna(code):
                                return (float('inf'),)
                            parts = code.split('.')
                            try:
                                return tuple(int(part) if part.isdigit() else float('inf') for part in parts)
                            except:
                                return (float('inf'),)
                        
                        # Сортируем DataFrame по коду строки (кроме итоговой строки)
                        temp_df = consolidated_df[consolidated_df['Код строки'] != 'ИТОГО']
                        total_row_df = consolidated_df[consolidated_df['Код строки'] == 'ИТОГО']
                        
                        temp_df['sort_key'] = temp_df['Код строки'].apply(sort_key)
                        temp_df = temp_df.sort_values('sort_key').drop('sort_key', axis=1)
                        
                        # Объединяем отсортированные данные с итоговой строкой
                        consolidated_df = pd.concat([temp_df, total_row_df], ignore_index=True)
                        
                        # Отображение результата
                        st.success(f"Сводный отчет создан из {len(dfs)} файлов (отсортировано по коду строки)")
                        
                        # Функция для стилизации строк
                        def style_row(row):
                            if row['Код строки'] == 'ИТОГО':
                                return ['font-weight: bold; background-color: #f0f0f0'] * len(row)
                            elif '.' in row['Код строки'] and not row['Код строки'].endswith('.'):
                                return [''] * len(row)
                            elif row['Код строки'].endswith('.'):
                                return ['font-weight: bold'] * len(row)
                            return [''] * len(row)
                        
                        st.dataframe(
                            consolidated_df.style.format({
                                'План': '{:,.2f}',
                                'Факт': '{:,.2f}',
                                'Отклонение': '{:,.2f}',
                                'План НД': '{:,.2f}',
                                'Факт НД': '{:,.2f}',
                                'Отклонение НД': '{:,.2f}'
                            }).apply(style_row, axis=1),
                            use_container_width=True,
                            height=800,
                            hide_index=True,
                            column_config={
                                "Код строки": st.column_config.TextColumn(width="small"),
                                "Статья расходов": st.column_config.TextColumn(width="large"),
                                "План": st.column_config.NumberColumn(width="medium"),
                                "Факт": st.column_config.NumberColumn(width="medium"),
                                "Отклонение": st.column_config.NumberColumn(width="medium"),
                                "План НД": st.column_config.NumberColumn(width="medium"),
                                "Факт НД": st.column_config.NumberColumn(width="medium"),
                                "Отклонение НД": st.column_config.NumberColumn(width="medium")
                            }
                        )
                        
                        # Экспорт в Excel
                        excel_data = BytesIO()
                        with pd.ExcelWriter(excel_data, engine='openpyxl') as writer:
                            consolidated_df.to_excel(writer, index=False, sheet_name='Сводный отчет')
                        
                        st.download_button(
                            label="Скачать сводный отчет (Excel)",
                            data=excel_data.getvalue(),
                            file_name="Сводный_отчет.xlsx",
                            mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                            key="download_consolidated_report"
                        )
                
                except Exception as e:
                    st.error(f"Ошибка при обработке файлов: {str(e)}")
        else:
            st.info("Загрузите от 1 до 30 файлов для формирования сводного отчета")

def save_to_excel(df, report_period):
    """Сохраняет DataFrame в Excel с правильным форматированием"""
    output = BytesIO()
    with pd.ExcelWriter(output, engine='openpyxl') as writer:
        df.to_excel(
            writer,
            sheet_name='Отчёт',
            index=False,
            columns=['Код строки', 'Статья расходов', 'План', 'Факт', 'Отклонение', 'План НД', 'Факт НД', 'Отклонение НД']
        )
        
        # Получаем объект workbook и worksheet для форматирования
        workbook = writer.book
        worksheet = writer.sheets['Отчёт']
        
        # Устанавливаем ширину столбцов
        worksheet.column_dimensions['A'].width = 10
        worksheet.column_dimensions['B'].width = 50
        for col in ['C', 'D', 'E', 'F', 'G', 'H']:
            worksheet.column_dimensions[col].width = 15
        
        # Форматирование чисел
        from openpyxl.styles import PatternFill

        yellow_fill = PatternFill(start_color='FFFF99', end_color='FFFF99', fill_type='solid')

        for i, row in enumerate(df.itertuples(index=False), start=2):
            if getattr(row, 'is_subsection', False) or row[0] == 'Итого':
                for j in range(1, 9):
                    worksheet.cell(row=i, column=j).fill = yellow_fill

        # Добавим дату в конец
        worksheet.cell(row=worksheet.max_row + 2, column=1, value="Период отчета:")
        worksheet.cell(row=worksheet.max_row, column=2, value=report_period)
        for row in worksheet.iter_rows(min_row=2, max_row=worksheet.max_row, min_col=3, max_col=8):
            for cell in row:
                cell.number_format = '#,##0.00'
    
    return output.getvalue()

if __name__ == "__main__":
    main()